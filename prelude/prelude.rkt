#lang racket
(require "vrectord.rkt")
(require "racket.rkt")
(require "num.rkt")
(require "hash.rkt")
(require "macros.rkt")

(require "../conf.rkt")
(prelude
 get
 '((define (null? x) (__null? x))
   (define (raise x) (__raise x))
   (define (with-exception-handler handler thunk)
     (if (procedure? handler)
         (if (procedure? thunk)
             (__with-exception-handler handler thunk)
             (error "with-exception-handler: isn't procedure" thunk))
         (error "with-exception-handler: isn't procedure" handler)))
   (define (cons a d) (__cons a d))
   (define (procedure? x) (__procedure? x))
   (define (number? x) (__number? x))
   (define (number->string x)
     (if (number? x)
         (__number->string x)
         (error "number->string: isn't number" x)))
   (define (string->number x)
     (if (string? x)
         (__string->number x)
         (error "string->number: isn't string" x)))
   (define (string-append x y)
     (if (string? x)
         (if (string? y)
             (__string-append x y)
             (error "string-append: isn't string" y))
         (error "string-append: isn't string" x)))
   (define (string? x) (__string? x))
   (define (symbol? x) (__symbol? x))
   (define (boolean? x) (__boolean? x))
   (define (symbol->string x)
     (if (symbol? x)
         (__symbol->string x)
         (error "symbol->string: isn't symbol" x)))
   (define (string->symbol x)
     (if (string? x)
         (__string->symbol x)
         (error "string->symbol: isn't string" x)))
   (define (apply f xs)
     (if (procedure? f)
         (if (list? xs)
             (__apply f xs)
             (error "apply: isn't list" xs))
         (error "apply: isn't procedure" f)))
   (define (car p)
     (if (pair? p)
         (__car p)
         (error "car: isn't pair" p)))
   (define (cdr p)
     (if (pair? p)
         (__cdr p)
         (error "cdr: isn't pair" p)))

   (define (error . xs) (raise (cons 'error xs)))
   (define (not x) (if x #f #t))
   (define (string . xs) (list->string xs))
   (define (displayln x) (display x) (newline))
   (define eqv? equal?)

   (defmacro delay-force
     (λ (x)
       `(delay (force ,x))))
   (define (make-promise x) (if (promise? x) x (delay x)))
   (define (memroizeeq f) f) ; zaoqil-core
   (define (memorize1eq f) f) ; zaoqil-core

   (define (list . xs) xs)
   (define (list? xs) (or (null? xs) (and (pair? xs) (list? (cdr xs)))))
   (define (map f xs)
     (if (null? xs)
         '()
         (cons (f (car xs)) (map f (cdr xs)))))
   (define (append xs ys)
     (if (null? xs)
         ys
         (cons (car xs) (append (cdr xs) ys))))
   (define (filter f xs)
     (if (null? xs)
         '()
         (if (f (car xs))
             (cons (car xs) (filter f (cdr xs)))
             (filter f (cdr xs)))))
   (define (foldl f x xs)
     (if (null? xs)
         x
         (foldl f (f (car xs) x) (cdr xs))))
   (define (length xs)
     (if (null? xs)
         0
         (+ 1 (length (cdr xs)))))
   (define (list-ref xs i)
     (if (zero? i)
         (car xs)
         (list-ref (cdr xs) (- i 1))))
   (define (%reverse xs rs)
     (if (null? xs)
         rs
         (%reverse (cdr xs) (cons (car xs) rs))))
   (define (reverse xs)
     (%reverse xs '()))
   (define (member x xs)
     (if (null? xs)
         #f
         (or (equal? (car xs) x) (member x (cdr xs)))))
   (define (ormap f xs)
     (if (null? xs)
         (or)
         (or (f (car xs)) (ormap f (cdr xs)))))
   (define (andmap f xs)
     (cond
       [(null? xs) (and)]
       [(null? (cdr xs)) (and (f (car xs)))]
       [else (and (f (car xs)) (andmap f (cdr xs)))]))
   (define (caar x) (car (car x)))
   (define (cadr x) (car (cdr x)))
   (define (cdar x) (cdr (car x)))
   (define (cddr x) (cdr (cdr x)))
   (define (caaar x) (car (car (car x))))
   (define (caadr x) (car (car (cdr x))))
   (define (cadar x) (car (cdr (car x))))
   (define (caddr x) (car (cdr (cdr x))))
   (define (cdaar x) (cdr (car (car x))))
   (define (cdadr x) (cdr (car (cdr x))))
   (define (cddar x) (cdr (cdr (car x))))
   (define (cdddr x) (cdr (cdr (cdr x))))
   (define first car)
   (define second cadr)
   (define third caddr)
   (define (assf f xs)
     (if (null? xs)
         #f
         (if (f (caar xs))
             (car xs)
             (assf f (cdr xs)))))
   (define (assoc x xs) (assf (λ (y) (equal? x y)) xs))

   (define gensym% (atom! 0))
   (define (gensym) (atom-map! (λ (x) (+ x 1)) gensym%))
   ))
